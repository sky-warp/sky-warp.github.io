---
title: Как я создавал свой DI для решения ТЗ
---

### Введение
Несколько месяцев назад, еще до момента, как я получил оффер от своей текущей компании, мне выслали очень интересное ТЗ, в котором одним из условий, повышающих твои шансы на его прохождение, было использование DI. Казалось бы, в наши дни, для любого Unity разработчика, DI-фреймворки являются базой, без которой банально невозможно найти работу. Я уже потирал ручки, представляя как сейчас буду импортировать Zenject в новый проект, но дочитав условие до конца, оказалось, что именно использование сторонних DI-фреймворков запрещено и допускаются только собственные решения. Поискав их  в открытом доступе, насмотревшись на разные реализации, мне все таки удалось написать простенький DI (даже в двух вариациях), со своим контейнером, инсталлером и атрибутами, про которые я расскажу в этой статье.

### Дисклеймер
 Данный материал не является обучающим, а также не претендует на истинность. Здесь не будет показано, как соблюдать SOLID, GRASP и прочие паттерны (за исключением самого DI), во благо простоты реализации и повествования. Данное решение можно расширять и рефакторить, однако в текущем виде оно справляется со своими основными задачами. 

У моего решения есть минусы, которые могут быть критическими для определенного круга лиц, поэтому, я считаю правильным проговорить их заранее.

Мое решение:
- не оптимально для работы со структурами, т.к. один из вариантов реализации работает по интерфейсу + большинство методов в обоих вариантах работает с `object`, что при работе со структурами будет черевато `boxing`\ `unboxing` (подробнее https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing);
- не подразумевает биндинг абстракций;
- ограниченный контроль жизненного цикла создаваемых объектов;
- LINQ. Да, тут есть один LINQ метод;

### DI как реализация IoC

Давайте с начала разберемся с терминами. 
Относительно `DI` (Dependency Injection) все понятно - это принцип, который снимает ответственность за внедрение и разрешение зависимостей с самого объекта и делегирует ее DI-системе (как показано на картинке ниже, эта система не обязательно должна быть DI-фреймворком).

<img src="C:\Users\Guilty\Desktop\guiltVault\Images\Pasted image 20251206120452.png">

С `IoC` (Inversion of Control) чуть посложнее - это принцип, подразумевающий построение архитектуры таким образом, чтобы модули были как можно более изолированными и менее связанны между друг другом.
Мне также нравится думать об IoC как о подходе, который говорит нам: "отними эту работу у своих модулей и скинь её на вот этих специалистов", чтобы мы как раз смогли писать менее связанный код (собственно в этом и есть "инверсия" из названия принципа).

`DI` является частным случаем `IoC`, который "отнимает" у ваших модулей работу по разрешению своих внутренних зависимостей.

Осталось разобраться с `IoC-контейнером`. IoC-container  - это библиотека/фреймворк, который предоставляет основной DI функционал, автоматизирует создание и хранение объектов, а также осуществляет менеджмент жизненного цикла объектов.

Можно также вскользь упомянуть о `Composition Root` - работяге создающим контракты зависимостей и разрешающий их (путем создания объектов, передачи уже созданных и т.д.). В Zenject'е эту роль играют инсталлеры.

### Принцип работы

>Можете почитать, как в С# реализован собственный DI, однако, я считаю, что это не слишком актуально для Unity разработки
>https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#dependency-inversion

Давайте теперь посмотрим на то, как это все работает.

<img src="C:\Users\Guilty\Desktop\guiltVault\Images\Pasted image 20251206114641.png">

Глобально это выглядит так:
- в традиционной парадигме ООП, сам объект должен решить все свои внутренние зависимости, что обычно достигается либо пробросом ссылок (в конструктор или Init() метод), либо созданием нового объекта;
- Dependency Injection предлагает нам хранить все контракты на зависимости в одном месте (Composition Root), которое при старте приложения и, если нужно, в рантайме, будет само "приходить" к объекту и отдавать ему объект нужного типа;

Я уже не в первый раз говорю о "контракте", что же это такое?

<img src="C:\Users\Guilty\Desktop\guiltVault\Images\Pasted image 20251206114923.png">

`Контракт` - это правило, в котором прописано:
- при обращении к какому типу, мы будем руководствоваться контрактом;
- какой объект мы будем отдавать при обращении к типу;
- какой будет жизненный отданного объекта

Выше, я перечислил только основные моменты, без которых мы не создадим ни одного контракта. Опционально, мы также можем указать, как именно будет создаваться объект, с какими аргументами, при соблюдении каких условий и проч.

Резюмируя, при реализации Dependency Injection мы:
1) Описываем, как резолвить тот или иной тип в контрактах;
2) Вызываем определенные методы для внедрения зависимостей;
3) Ждем пока фреймворк найдет нужный контракт и согласно его условиям вернет определенный объект;

>Для того, чтобы само приложение понимало, что резолвить самостоятельно, а что через DI-фреймворк, у последнего обычно есть определенные синтаксический правила, к примеру атрибуты или названия методов (как [Inject] в Zenject'е).

### Реализация

Как уже было упомянуто во введении, я реализовал две версии DI. Первая - не типо-безопасная, где мы можем забиндить что угодно, как угодно, сколько угодно раз, через root-тип `object`. Вторая - более типо-безопасная, где любой бинд, сначала, нужно обернуть в соответствующий интерфейс, в очереди биндов есть словарь со значением листа, содержащего все бинды данного типа (чтобы при нескольких биндах одного типа мы могли прописать логику, какой же все таки брать).

Давайте начнем с первого варианта, чтобы потом нагляднее увидеть разницу.

`BindStorage`
Это место, в которое мы будем складывать наши забинженные объекты  (с вашего позволения, далее вместо слишком абстрактного "контракт" я буду использовать "бинд" и его производные)

```c#
public class BindStorage  
{  
    private List<object> _bindQueue = new();  
  
    public void Bind(object obj)  
    {        
        _bindQueue.Add(obj);  
    }  
    public bool TryGetBindedObject(Type targetType, out object result)  
    {        
        for (int i = 0; i < _bindQueue.Count; i++)  
        {            
            var currentObject =  _bindQueue[i];  
            var currentType = currentObject.GetType();  
  
            if (targetType.IsAssignableFrom(currentType))  
            {                
                result = currentObject;                
                return true;  
            }        
        }

        result = null;  
        return false;  
    }}
```

Здесь все просто. Есть какая-то коллекция, в которую попадают объекты, после вызова `Bind()` и есть метод `TryGetBindedObject()` который возвращает первый объект, тип которого  совпадает с типом переданного параметра.

`InjectStorage`
Аналогичен по логике работы с `BindStorage`, однако тут нам не надо ничего искать.

```c#
public class InjectStorage  
{  
    private readonly List<object> _injectQueue = new();  
  
    public void Inject(object target)  
    {        
        if (!_injectQueue.Contains(target))  
            _injectQueue.Add(target);  
        else  
            Debug.LogError($"You are trying to inject the same object {target} more than once!");  
    }  
    
    public void ClearInjectQueue()  
    {       
	    _injectQueue.Clear();  
    }  
    public List<object> GetInjectQueue()  
    {        
	    return _injectQueue;  
    }
}
```

Перед добавлением смотрим, чтобы такого объекта уже не было в очереди на инжект (опять же, далее это слово эквивалентно "внедрение зависимостей").
Методы `ClearInjectQueue`\ `GetInjectQueue` позволяют очистить и получить очередь на инжект.

`DInjector`
Наш IoC-контейнер. Как я предупреждал в дисклеймере, здесь нет полноценного контроля жизненного цикла создаваемых объектов, как и их хранения. Это легко решается одной коллекцией и реализацией `IDisposable` (как на самих объектах, так и в `DInjector`) либо, если у вас более сложная система загрузки ваших ресурсов, замените `Dispose()` на ваш метод выгрузки ресурсов и вызывайте вручную при отработке `DInjector`. 

Этот модуль довольно объемный, поэтому давайте рассмотрим его части чуть более подробнее.

```c#
public class DInjector  
{  
    private readonly BindStorage _bindStorage;  
    private readonly InjectStorage _injectStorage;  
  
    public DInjector(BindStorage bindStorage, InjectStorage injectStorage)  
    {   
        _bindStorage = bindStorage;  
        _injectStorage = injectStorage;  
    }  
    
    public void InjectAll()  
    {        
        var queue = _injectStorage.GetInjectQueue();  
  
        for (int i = queue.Count - 1; i >= 0; i--)  
        {            
	        Inject(queue[i]);  
        }    
    }
```

Прокидываем наши очереди инжекта и биндингов. `InjectAll()` итерирует через все объекты из `InjectStorage` и вызывает для них `Inject()`

```c#
private void Inject(object obj)  
{  
    if (MethodValidation(obj, obj.GetType()) == false)  
        Debug.Log(obj.GetType().Name + " no methods to inject");  
}  
  
private bool MethodValidation(object obj, Type targetType)  
{  
    int methodsToInject = 0;  
  
    foreach (var method in targetType.GetMethods())  
    {       
        if (method.GetCustomAttributes<DInjection>(true).Any())  
        {            
	        InjectMethod(obj, method);  
            methodsToInject++;        
        }    
    }  
    
    if (methodsToInject == 0)  
    {       
        Debug.Log($"No methods for injecting for {targetType.Name} in {obj} object");  
        return false;  
    }  
    return true;  
}
```

Здесь начинается самое интересное. `Inject()` вызывает `MethodValidation()`. Тут мы получаем объект, в который нужно заинжектить зависимости, и таргетный тип, который нужно найти и согласно контракту (о `Composition Root` позже) и вернуть соответствующий объект. Однако, было бы проблематично итерировать через весь объект и его члены. В данной реализации мы работаем только с методами, через кастомный атрибут `DInjection`. Через методы рекурсии `GetCustomAttributes` ищем все методы с этим атрибутом и вызываем финальный `InjectMethod.

```c#
private void InjectMethod(object target, MethodInfo method)  
{  
    var parameters = method.GetParameters();  
  
    var resolvedArgs = new object[parameters.Length];  
  
    for (int i = 0; i < parameters.Length; i++)  
    {        
        var parameter = parameters[i];  
        var parameterType = parameter.ParameterType;  
  
        if (_bindStorage.TryGetBindedObject(parameterType, out var arg) == false)  
        {            
            WarningLog(parameterType, method, target);  
            return;  
        }  

        if (arg.GetType().GetCustomAttributes<AsTransientBind>().Any())  
        {            
            var newInstance = Activator.CreateInstance(parameterType);  
            MethodValidation(newInstance, newInstance.GetType());  
  
            resolvedArgs[i] = newInstance;            continue;  
        }  

        resolvedArgs[i] = arg;    
    }
      
    method.Invoke(target, resolvedArgs);  
}  
  
private void WarningLog(Type parameterType, MethodInfo method, object target)  
{  
    Debug.LogError($"Cannot inject parameter of type {parameterType} " +  
                   $"for method {method.Name} in class {target.GetType()}. " +  
                   "No binded object found.");  
}
```

Получаем все параметры переданного метода, ищем тип параметра в `BindStorage` через `TryGetBindedObject` и записываем получившийся результат в массив `resolvedArgs`, который будет передан в `method.Invoke(target, resolvedArgs)`. 

Вторая проверка полученного аргумента на наличие атрибута `AsTransientBind` связанна с другим типом жизненного цикла, при котором, каждое новое обращение к забинженому типу будет возвращать новый объект. Если мы находим в аргументе такой атрибут, мы создаем  через `Activator.CreateInstance(parameterType)` новый объект, и уже для него заново запускаем цепочку, начиная с `MethodValidation`.

`DiContainer`
Собственно, наш контейнер, который является просто фасадом для обращения к методам из типов, описанных выше

```c#
public class DiContainer  
{  
    private readonly BindStorage _bindStorage;  
    private readonly InjectStorage _injectStorage;  
    private readonly DInjector _dInjector;  
  
    public DiContainer()  
    {        
        _bindStorage = new BindStorage();  
        _injectStorage = new InjectStorage();  
        _dInjector = new DInjector(_bindStorage, _injectStorage);  
    }  

    public void Bind(object target) => _bindStorage.Bind(target);  
  
    public void Inject(object target) => _injectStorage.Inject(target);  
  
    public void ClearInjectQueue() => _injectStorage.ClearInjectQueue();  

    public void InjectAll() => _dInjector.InjectAll();  
}
```

`DInjection`\ `AsTransient`
Кастомные атрибуты,  о которых мы уже говорили

```c#
[MeansImplicitUse(ImplicitUseKindFlags.Default)]  
[AttributeUsage(AttributeTargets.Method)]  
public class DInjection : Attribute  
{  
}

[MeansImplicitUse(ImplicitUseKindFlags.Default)]  
[AttributeUsage(AttributeTargets.Class)]  
public class AsTransientBind : Attribute  
{  
}
```

`GameInstaller`
Наш Composition Root.

```c#
public class GameInstaller : MonoBehaviour  
{  
    [SerializeField] private  EntryPoint _entryPoint;  
    [SerializeField] private SecondEntryPoint _secondEntryPoint;  
  
    [SerializeField] private InstanceDummyScript _dummyPrefab;  
  
    private  DiContainer _diContainer;  
  
    public void Initialize(DiContainer container)  
    {        
        _diContainer = container;  
    }  

    public void InstallBindings()  
    {        
        BindPrefab(_dummyPrefab);  
        BindAsSingle(new SingleLogger());  
        BindAsTransient(new TransientLogger());  
  
        Inject(_entryPoint);  
        Inject(_secondEntryPoint);  
    } 

    private void Inject(object instance)  
    {        
        _diContainer.Inject(instance);  
    }

    private void BindPrefab(MonoBehaviour prefab)  
    {        
        _diContainer.Bind(prefab);  
    } 
     
    private void BindAsSingle(object instance)  
    {        
        _diContainer.Bind(instance);  
    }  

    private void BindAsTransient(object instance)  
    {        
        _diContainer.Bind(instance);  
    }
}
```

Хоть это и MonoBehaviour, но он не обязательно должен быть таковым. Здесь мы создаем наши биндинги. Это самая примитивная реализация, где по сути нужен один метод, но Я его по сути продублировал, чтобы было. Все методы биндинга (`BindPrefab`, `BindAsSingle`, `BindAsTransient`) делают одно и то же - помещают объект в коллекцию `BindStorage`.
`Inject()` добавлен, чтобы сразу из инсталлера поместить объекты в очередь на инжект.

Собственно, с первым вариантом мы разобрались. Это рабочая система, однако мне она не нравится, как раз тем самым дублированием кода и необходимостью биндить все через `object`.

>Дабы не увеличивать и без того большой материал, здесь не будет описание примеров этой системы. Вместо этого, они будут лежать в отдельной папке git-репозитория, в котором также будем сам Unity-проект. Ссылка на git ждет в самом конце. 

Давайте теперь разберем второй пример, а точнее, что в нем поменялось.

`IBindable`

```c#
public interface IBindable  
{  
    Type TargetType { get; }  
    object Resolve();  
}
```

Вынесем все объекты, которые будем биндить, в отдельный интерфейс. В нем только тип объекта, который мы оборачиваем, и метод, который будет возвращать сам объект.

>Тут может возникнуть резонный вопрос: "А в чем смысл, если объект будет сам решать свою зависимость + возвращать object?". Второй вопрос обойти достаточно просто, просто превратив его в дженерик (но рефакторинг на этом не закончиться, и нужно будет превращать в дженерики и остальные методы, которые используют `IBindable`). По поводу второго вопроса - сам метод выступает как часть контракта. В реализациях интерфейса, будет разная логика того, как мы будем получать сам объект. Биндинг и поиск нужного объекта все также находится в зоне ответственности `BindStorage`, а не объекта.

`AsSingleBind<T>` и `AsTransientBind<T>`

```c#
public sealed class AsSingleBind<T> : IBindable where T : class  
{  
    private T _instance;  
  
    public Type TargetType => typeof(T);  
  
    public AsSingleBind(T instance) => _instance = instance;  
  
    public object Resolve() => _instance;  
}

public sealed class AsTransientBind<T> : IBindable where T : class  
{  
    public Type TargetType => typeof(T);  
  
    private DiContainer _diContainer;  
  
    private T _instance;  
    private bool _isMonoB;  
  
    public AsTransientBind(DiContainer diContainer)  
    {        
        _diContainer = diContainer;  
        _isMonoB = false;  
    }  

    public AsTransientBind(T prefab)  
    {        
        _instance = prefab;  
        _isMonoB = true;  
    }  
    public object Resolve()  
    {        
        if (_isMonoB)  
        {            
            return _instance;  
        }  
              
        return _instance = (T)_diContainer.FactoryMethod<T>();  
    }
}
```

`AsSingleBind` - это обертка, для объектов, жизненный цикл которых схож с Singleton'ом (существует в одном экземпляре).

`AsTransientBind`, по аналогии из прошлой версии, нужен чтобы биндить объекты, каждое обращение к которым будет создавать новый экземпляр.

Логика работы у них одинаковая:
- при создании объекта в конструктор прокидываем экземпляр, чтобы он выступал в качестве объекта, который отдаст метод `Resolve()`;
- у `AsTransient` два конструктора (т.к. я не написал фабрику для монобехов), один работает аналогично предыдущему пункту (и нужен как раз чтобы биндить монобехи), а второй случай подразумевает проброс `DiContainer` и вызов его фабрики(в идеале конечно отказаться от AsTransient монобехов, но оставим это, как потенциальную ось расширения);

>Тут же кстати можно и обойти ограничение, связанное с биндингом абстракций. Никто не мешает сделать дженерик в виде `AsSingle<T, TImpl> T : class where TImpl : T`. И да, тут же можно заметить, что я ограничил биндинг только для классов, хотя если вы не боитесь в `Resolve()` получить боксинг, можете смело убирать `where`

`GameInstaller`
Поменялась логика биндинга.

```c#
public class GameInstaller : MonoBehaviour  
{  
    [SerializeField] private Bootstrap _bootstrap;  
    [SerializeField] private EntryPoint _entryPoint;  
    [SerializeField] private SecondEntryPoint _secondEntryPoint;  
  
    [SerializeField] private TransientSpawner1 _transientSpawner1;  
    [SerializeField] private TransientSpawner2 _transientSpawner2;  
  
    [SerializeField] private InstanceDummyScript _dummyPrefab;  
    [SerializeField] private InstanceTransientDummyScript _transientDummyPrefab;  
  
    private DiContainer _diContainer;  
  
    public void Initialize(DiContainer container)  
    {        
	    _diContainer = container;  
    }  
    
    public void InstallBindings()  
    {        
        AsSingleBind<InstanceDummyScript> dummyPrefab = new(_dummyPrefab);  
        _diContainer.Bind(dummyPrefab);  
  
        AsSingleBind<SingleLogger> logger = new(new SingleLogger());  
        _diContainer.Bind(logger);  
  
        AsTransientBind<TransientLogger> transientLogger =  
            new AsTransientBind<TransientLogger>(_diContainer);  
        _diContainer.Bind(transientLogger);  
  
        AsSingleBind<TransientSpawner1> transientSpawner1 = new AsSingleBind<TransientSpawner1>(_transientSpawner1);  
        AsSingleBind<TransientSpawner2> transientSpawner2 = new AsSingleBind<TransientSpawner2>(_transientSpawner2);  
        _diContainer.Bind(transientSpawner1);  
        _diContainer.Bind(transientSpawner2);  
  
        AsTransientBind<InstanceTransientDummyScript> transientDummyPrefab =  
            new AsTransientBind<InstanceTransientDummyScript>(_transientDummyPrefab);  
        _diContainer.Bind(transientDummyPrefab);  
  
        AsSingleBind<EntryPoint> entryPoint = new(_entryPoint);  
        AsSingleBind<SecondEntryPoint> secondEntryPoint = new(_secondEntryPoint);  
        _diContainer.Bind(entryPoint);  
        _diContainer.Bind(secondEntryPoint);  
  
        Inject(_bootstrap);  
        Inject(_entryPoint);  
        Inject(_secondEntryPoint);  
        Inject(_transientSpawner1);  
        Inject(_transientSpawner2);  
    }  
    
    private void Inject(object instance)  
    {        
        _diContainer.Inject(instance);  
    }
}
```

Теперь, для любого биндинга нам нужно создать объект типа, реализующего `IBindable` и вызвать `_diContainer.Bind()`. Как же теперь работает очередь забинженных объектов.

`BindStorage`

```c#
public class BindStorage  
{  
    Dictionary<string, List<IBindable>> _bindQueue = new(); 
     
    public void Bind(IBindable obj)  
    {         
        string key = obj.TargetType.ToString();  
  
        if (!_bindQueue.TryGetValue(key, out var list))  
        {            
	        list = new List<IBindable>();  
            _bindQueue[key] = list;  
        }                
        
        list.Add(obj);  
    }  
    
    public bool TryGetBindedObject(Type targetType, out object obj)  
    {        
        if (_bindQueue.TryGetValue(targetType.ToString(), out var list) && list.Count != 0)  
        {            
            obj = list[0].Resolve();  
            return true;  
        }  
        
        obj = null;  
        return false;  
    }
}
```

Ключевых отличий два:
- коллекция биндингов теперь содержит не `object`, а `IBindable` объекты (ну и теперь это не лист, а словарь с листом `IBindable` в качестве значения и ключем в виде самого типа, конвертированного в строку);
- когда мы хотим получить объект по типу через `TryGetBindedObject`, мы обращаемся к первому элементу из листа под соответствующим ключем словаря, чтобы даже при бинде одного и того же типа несколько раз, мы брали самый первый;

`InjectStorage` остался таким же 

```c#
public class InjectStorage  
{  
    private readonly List<object> _injectQueue = new();  
  
    public void Inject(object target)  
    {        
        if (!_injectQueue.Contains(target))  
        {
            _injectQueue.Add(target);
        }
        else  
        {
            Debug.LogError($"You are trying to inject the same object {target} more than once!");  
        }
    }  
    
    public void ClearInjectQueue()  
    {        
        _injectQueue.Clear();  
    }  
    
    public List<object> GetInjectQueue()  
    {        
        return _injectQueue;  
    }
}
```

`DInjector`

```c#
public class DInjector  
{  
    private readonly BindStorage _bindStorage;  
    private readonly InjectStorage _injectStorage;  
  
    public DInjector(BindStorage bindStorage, InjectStorage injectStorage)  
    {        
        _bindStorage = bindStorage;  
        _injectStorage = injectStorage;  
    }  
    
    public void InjectAll()  
    {        
        var queue = _injectStorage.GetInjectQueue();  
  
        for (int i = queue.Count - 1; i >= 0; i--)  
        {            
            CheckResolve(queue[i]);  
        }    
    } 
     
    private void CheckResolve(object obj)  
    {        
        if (Resolve(obj, obj.GetType()) == false)  
            Debug.Log(obj.GetType().Name + " no methods to inject");  
    }  
    
    private bool Resolve(object obj, Type targetType)  
    {        
        int methodsToInject = 0;  
  
        foreach (var method in targetType.GetMethods())  
        {            
            if (method.GetCustomAttributes<DInjection>(true).Any())  
            {                
                ResolveMethod(obj, method);  
                methodsToInject++;            
            }       
        }  
        if (methodsToInject == 0)  
        {            
            Debug.Log($"No methods for injecting for {targetType.Name} in {obj} object");  
            return false;  
        }  
        
        return true;  
    }  
    
    private void ResolveMethod(object target, MethodInfo method)  
    {        
        var parameters = method.GetParameters();  
  
        var resolvedArgs = new object[parameters.Length];  
  
        for (int i = 0; i < parameters.Length; i++)  
        {            
            var parameterType = parameters[i].ParameterType;  
  
            if (_bindStorage.TryGetBindedObject(parameterType, out var arg) == false)  
            {                
                WarningLog(parameterType, method, target);  
                return;  
            } 
             
            if (arg.GetType().GetCustomAttributes<AsTransient>(true).Any())  
            {                
                Resolve(arg, arg.GetType());  
            }  
            
            resolvedArgs[i] = arg;        
        }  
        
        method.Invoke(target, resolvedArgs);  
    }  
    
    private void WarningLog(Type parameterType, MethodInfo method, object target)  
    {        
        Debug.LogError($"Cannot inject parameter of type {parameterType} " +  
                       $"for method {method.Name} in class {target.GetType()}. " + 
                       "No binded object found.");  
    }
}
```

Переименовал основные методы.
Логика работы осталась такой же:
- мы получаем наши очереди забинженных объектов + очередь для инъекции;
- `InjectAll()`, который вызывается через `DiContainer` (который в свою очередь вызывается через бутстрап) проходит по всем объектам из очереди `InjectStorage` и вызывает `CheckResolve()`;
- `Resolve()` получает объект, таргетный тип, собирает с типа методы с атрибутом для инъекции `[DInjection]`;
- `ResolveMethod()` также получает все параметры метода, пытается зарезолвить их через очередь `BindStorage` + смотрим, если у параметра есть атрибут `AsTransient`, то передаем его обратно в цепочку, начиная с `Resolve()`, чтобы разрешить и его зависимости;
- в конце вызываем метод с полученными параметрами;

Ну и на последок, наш`DiContainer`

```c#
public class DiContainer  
{  
    private readonly BindStorage _bindStorage;  
    private readonly InjectStorage _injectStorage;  
    private readonly DInjector _dInjector;  
  
    public DiContainer()  
    {        
        _bindStorage = new BindStorage();  
        _injectStorage = new InjectStorage();  
        _dInjector = new DInjector(_bindStorage, _injectStorage);  
    }  
    
    public void Bind(IBindable target) => _bindStorage.Bind(target);  
  
    public void Inject(object target) => _injectStorage.Inject(target);  
  
    public void ClearInjectQueue() => _injectStorage.ClearInjectQueue(); 
     
    public void InjectAll() => _dInjector.InjectAll();  
  
    public object FactoryMethod<T>()  
    {        
        var result = Activator.CreateInstance(typeof(T));  
        return result;  
    }
}
```

Основные изменения:
- `Bind()` теперь принимает `IBindable`;
- Появился `FactoryMethod<T>` для создания transient объектов 

>В принципе, сюда можно было бы вынести и логику создания сингл-объектов.

### Заключения

Хочется еще раз уточнить, что у обоих систем есть свои минусы, которые я описал в самом начале статьи, однако, что первый, что второй вариант более чем справляется со своей задачей - внедряет зависимости в определенные типы.

Весь код, сцена с примерами, будет доступна на моем git. 

Буду рад любому фидбеку, как по содержанию статьи, учитывая, что это моя первая проба пера в написании технического материала, так и по моей реализации DI.

Спасибо что дочитали до конца.